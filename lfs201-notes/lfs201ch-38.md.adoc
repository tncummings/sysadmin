:doctype: book

Chapter 38 - GRUB

= Chapter 38 - GRUB

== Chapter 38 Introduction

A system that can not start up on its own is rather useless.
Linux systems have a lot of flexibility in how they boot.
It is possible to choose between different kernel versions or options, or even different operating systems in multiple-boot scenarios.
Most non-embedded systems use the Grand Unified Boot Loader to accomplish the first steps of a successful system initialization.
GRUB also has interactive capabilities as well as a secure password facility.

== Learning Objectives

By the end of this chapter, you should be able to:

* Explain what the role of GRUB is.
* Understand the differences between the GRUB 1 and GRUB 2 versions.
* Explain the interactive selections you can make at boot.
* Install GRUB.
* Explain how the configuration files that GRUB needs are used and modified.

== What Is GRUB?

Virtually, all x86-based Linux systems (outside the embedded sphere) today use GRUB (GRand Unified Bootloader) to handle the early phases of system startup.
Other platforms may have other equivalents, such as ELILO used on EFI systems such as IA64 (Itanium), and Das U-BOOT used on many embedded configurations.

Some important features of GRUB are:

* Alternative operating systems can be chosen at boot time.
* Alternative kernels and/or initial ramdisks can be chosen at boot time for a given operating system.
* Boot parameters can be easily changed at boot time without having to edit configuration files, etc., in advance.

Version 2 has replaced Version 1 on all major Linux distributions except for RHEL 6-based ones.

== GRUB Versions

While details are different between GRUB 2 and the legacy Version 1, the basic philosophy is the same.

At boot, a basic configuration file is read, `/boot/grub/grub.cfg`, or `/boot/grub2/grub.cfg`, or `/boot/efi/EFI/redhat/grub.cfg`.

This file is auto-generated by update-grub (or grub2-mkconfig) based on configuration files in the /etc/grub.d directory and on /etc/default/grub and should not be edited by hand.
Usually, these utilities are run from other distribution-supplied scripts used for updating or compiling Linux kernels.

Once again the file is better off not being edited by hand.
However, if you do make changes, most of the time they will be preserved.

== Interactive Selections with GRUB at Boot

Upon system boot, after the initial POST and BIOS stages, GRUB will be entered and display a menu containing a list of bootable images either from one or more Linux distributions or operating systems.
There may also be submenus with even more choices.

Using up and down arrows and the Enter key, you can select the right boot option, or can wait for a configurable time period before the default choice is entered.

However, you can do much more.
After selecting an entry, you can type e for edit and then enter into an interactive shell.
In this shell, you can alter the stanza in the configuration file that describes that particular boot option.
Usually, you do this to alter the kernel command line;
for example, adding the word single at the end of the command line will cause the system to boot in single use mode in order to take corrective actions.
Once the desired change is made, you can hit the right key to make the system boot.

At the bottom of the screen you will see displayed information on the exact key strokes, so there is no need to memorize.
image:../../_resources/53811888edc14e9c9bf9dd104947598f.png[72da682b42ff11e332a079fed3d8daf4.png]

It is also possible to enter a pure shell, rather than edit a particular stanza.
You can run a number of different commands and even try to re-install or repair GRUB.
If there are serious problems, like not being able to find a configuration file, GRUB reverts back to this command line mode and you may be able to rescue the system without resorting to rescue media.

== Installing GRUB

The word installing can have several different meanings with respect to GRUB:

. Installing the grub program and associated utilities in their proper locations.
In GRUB 1 there was actually a program just called grub, but in GRUB 2 there are a bunch of utilities with names like grub2-* or grub-*;
how they are packaged is rather distribution-dependent.
. Installing the files GRUB needs to operate at boot time, under either /boot/grub or /boot/grub2.
This is separate than the files the Linux kernel needs (vmlinuz-_, initramfs-_) which will need to be in the /boot directory as well.
. Installing GRUB as the boot loader in the system;
usually, this is done at the front of the entire hard disk, but can also be done in a partition.

If you do not install GRUB during system installation, or you need to re-install at some later point, the exact procedure for doing so depends on the GRUB version.

For Version 2, the installation procedure can be as easy as:

`$ sudo grub2-install /dev/sda`

Please read the man page carefully before running such a command;
there are many options, and messing up GRUB can make your system un-bootable.

Note on EFI multi-boot systems, you may have to also run efibootmgr as things can be more complex.
See the man page for more details.

== GRUB Device Nomenclature

In both GRUB versions, the first hard drive is denoted as hd0, the second is hd1, etc.
However, in Version 1, partitions start counting from 0, and in Version 2 from 1:

* sda1 is (hd0,1) in GRUB 2, but (hd0,0) in GRUB 1
* sdc4 is (hd2,4) in GRUB 2, but (hd2,3) in GRUB 1.

There is no need to emphasize that getting confused about this can be rather destructive.
Both versions of GRUB sometimes use the sda# notation, and sometimes use (hd0,#), so it can get further confusing.

Within the configuration file, each stanza has to specify what the root partition is;
this is not the same as what we mean when we talk about the root directory of the system.
In this context, it means the partition contains the kernel itself (in the /boot directory).
For example, it is very common to have /boot in its own partition, lets say /dev/sda1.

It is also fine to do kernel (hd0,0)/vmlinuz\....
instead, and leave out the root line.

A quick look at grub.cfg should make it clear.

== GRUB Configuration Files

Remember that you should not edit `/boot/grub/grub.cfg` (or `/boot/grub2/grub.cfg`) directly.
For GRUB 2, there are two locations in the /etc directory that should require attention and are used to reconstruct grub.cfg whenever the system is altered with new kernels, or the relevant updating program (such as update-grub or grubby) is manually run.

The first one is `/etc/default/grub`.
The screenshot shows you how it looks like on RHEL 8: image:../../_resources/f1960be9258c4fae860ff8f48b298ba6.png[0ddd292701d7262e87e6cdddffd824bb.png]

The other directory that matters is `/etc/grub.d`.
The screenshot shows you how it looks like on Ubuntu 19.10.
image:../../_resources/2b9626ab85fa40108ff6fe477522f2e7.png[f36982a7a166162555cedd483b4ea97d.png]

Each of the two files (`/etc/default/grub` and `/etc/grub.d`) runs in ascending order when the configuration file is updated.

New file can be generated by *grub2-mkconfig* or *grub-mkconfig*.

== Boot Loader Specification Configuration (BLSCFG)

On systems configured with BLSCFG one still uses the usual grub commands when installing or updating kernels, etc.
When booting one will still see the same interactive grub screen and use it as it has always been done.

However, some differences are important.
For example, while `/boot/grub2/grub.cfg` still exists, detailed information and options for each kernel that can be chosen does not appear there;
it is in `/boot/loader/entries`, one file for each choice.

It is possible to switch to the new scheme by running the `grub2-switch-to-blscfg` program.
One can also turn the new method on and off by altering the the variable `GRUB_ENABLE_BLSCFGS=[true|false]`.
For example on a RHEL 8 system:

``` $ sudo cat /etc/default/grub

GRUB_TIMEOUT=5 GRUB_DISTRIBUTOR="$(sed 's, release .*$,,g' /etc/system-release)" GRUB_DEFAULT=saved GRUB_DISABLE_SUBMENU=true GRUB_TERMINAL_OUTPUT="console" GRUB_CMDLINE_LINUX="crashkernel=auto rhgb quiet" GRUB_DISABLE_RECOVERY="true" GRUB_ENABLE_BLSCFG=true ```

See https://systemd.io/BOOT_LOADER_SPECIFICATION/["The Boot Loader Specification"] article for more information.

== `/boot/loader/entries`

With the boot loader specification configuration scheme, each possible kernel gains an entry in `/boot/loader/entries`.

A number of environmental variables may be set in /boot/grub2/grubenv, including:

 kernelopts
 tuned_initrd
 tuned_params
 grub_users

`/boot/grub2/grubenv` also sets the default boot kernel:

`+ #GRUB Environment Block kernelopts=root=UUID=6921b738-1e36-429a-89be-8b97cf2f0556 ro boot_success=0 boot_indeterminate=0 saved_entry=ce0c82382a8a4c80bbd6931a917a2f1c-5.11.6.0~custom ################################################################################.....
+`

== Lab 38.1: Booting into Non-Graphical Mode Using GRUB

Please Note This exercise requires that it be run from the console (i.e., not over SSH).
1.
Reboot your machine and go into the GRUB interactive shell by hitting e (or whatever other key is required as listed on your screen.) 2.
Make your system boot into non-graphical mode.
How you do this depends on the system.
On traditional systems that respect runlevels (which we will talk about in the next section) you can append a 3 to the kernel command line in the specific entry you pick from the GRUB menu of choices.
This will still work on systemd systems that still bother to emulate SysVinit runlevels.
On some other systems you may need to append text instead.
3.
Hit the proper key to make system continue booting.
4.
After the system is fully operational in non-graphical mode, bring it up to graphical mode.
Depending on your system, one of the following commands should do it: ` $ sudo systemctl start gdm $ sudo systemctl start lightdm $ sudo telinit 5 $ sudo service gdm restart $ sudo service lightdm restart `
