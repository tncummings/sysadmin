:doctype: book
:pp: {plus}{plus}

Chapter 14 - I/O Monitoring and Tuning

= Chapter 14 - I/O Monitoring and Tuning

## Learning Objectives

By the end of this chapter, you should be able to:

* Understand the importance of monitoring I/O activity and when it constitutes system performance bottlenecks.
* Use iostat to monitor system I/O device activity.
* Use iotop to display a constantly updated table of current I/O usage.
* Use ionice to set both the I/O scheduling class and the priority for a given process.

== I/O Monitoring and Disk Bottlenecks

Disk performance problems can be strongly coupled to other factors, such as insufficient memory or inadequate network hardware and tuning.
Disentangling can be difficult.

*_As a rule, a system can be considered as I/O-bound when the CPU is found sitting idle waiting for I/O to complete, or the network is waiting to clear buffers._*

However, one can be misled.
What appears to be insufficient memory can result from too slow I/O;
if memory buffers that are being used for reading and writing fill up, it may appear that memory is the problem, when the real problem is that buffers are not filling up or emptying out fast enough.
Similarly, network transfers may be waiting for I/O to complete and cause network throughput to suffer.

Both real-time monitoring and tracing are necessary tools for locating and mitigating disk bottlenecks.
However, rare or non-repeating problems can make this difficult to accomplish.

There are many relevant variables and I/O tuning is complex.
We will also consider I/O scheduling later.

== iostat

iostat is the basic workhorse utility for monitoring I/O device activity on the system.
It can generate reports with a lot of information, with the precise content controlled by options.

`$ iostat [OPTIONS] [devices] [interval] [count]`

You can see in this screenshot what simply typing iostat gives us.

image::../../_resources/532b28e2a9344837ba0131d5345c646f.png[a1ff06cf5b490cbe9ec8cab996f04cb1.png]

=== iostat

After a brief summary of CPU utilization, I/O statistics are given: tps (I/O transactions per second;
logical requests can be merged into one actual request), blocks read and written per unit time, where the blocks are generally sectors of 512 bytes;
and the total blocks read and written.

Information is broken out by disk partition (and if LVM is being used also by dm, or device mapper, logical partitions).

A somewhat different display is generated by giving the -k option, which shows results in KB instead of blocks.
You can also use -m to get results in MB.

`$ iostat -k`

image::../../_resources/8f43a8135cfa4797a0a12b80e90a2910.png[80d2d2819a6fb7712db530ef24fbb46c.png]

*Using iostat with the -k Option to See Results in KB*

Another useful option is -N, to show by device name (or -d for a somewhat different format), as in the screenshot provided.

$ iostat -N

image::../../_resources/3c02e1326303425ab0a89a34711506fa.png[e8033a88543d6983762f807c99f0e531.png]

*Using iostat with the -N Option to See Results by Device Name*

A much more detailed report can be obtained by using the -x option (for extended).

`$ iostat -xk`

image::../../_resources/e2c120a46e3040cc828da83e1fc7731e.png[72c9bcc4ef5e742202533101f149bbba.png]

*Using iostat to Get a More Detailed Report*

*_Note that if the utilization percentage approaches 100, the system is saturated, or I/O bound._*

== iotop

Another very useful utility is iotop, which must be run as root.
It displays a table of current I/O usage and updates periodically, like top.
You can see in the screenshot what typing sudo iotop with no options gives us.

Please note that the be and rt entries in the PRIO field are explained in the ionice section, and stand for best effort and real time.

image::../../_resources/c2b07835e87c4295b6438dc3cc5898a1.png[ebbedc3b07ee52202da82b995faa8ffa.png]

*Using iotop*

Available options can be shown by using the --help option.

`$ iotop --help`

image::../../_resources/a660607dfe124bc5a9afcaccdf02780f.png[a7b01fabf8f0fc3f1eef34a21e437f09.png]

*iotop Options*

Using the -o option can be useful to avoid clutter.

== ionice

The ionice utility lets you set both the I/O scheduling class and priority for a given process.
It takes the form:

`$ ionice [-c class] [-n priority] [-p pid ] [COMMAND [ARGS] ]`

If a pid is given with the -p argument results apply to the requested process, otherwise it is the process that will be started by COMMAND with possible arguments.
If no arguments are given, ionice returns the scheduling class and priority of the current shell process, as in:

` $ ionice idle: prio 7 `

The -c parameter specifies the I/O scheduling class, as shown in the table below.

Table: I/O Scheduling Classes

*Scheduling Class	-c Value	Meaning* - None or Unknown	0	Default value - Real Time	1	Get first access to the disk, can starve other processes.
The priority defines how big a time slice each process gets.
- Best Effort	2	All programs serviced in round-robin fashion, according to priority settings.
The Default.
- Idle	3	No access to disk I/O unless no other program has asked for it for a defined period.

The Best Effort and Real Time classes take the -n argument which gives the priority, which can range from 0 to 7, with 0 being the highest priority.
An example can be seen below:

`$ ionice -c 2 -n 3 -p 30078`

*_ionice works only when using the CFQ I/O Scheduler, which was removed in the 5.0 kernel version._*

== Exercise 14.1: bonnie{pp}

bonnie{pp} is a widely available benchmarking program that tests and measures the performance of drives and filesystems.
It is descended from bonnie, an earlier implementation.
Results can be read from the terminal window or directed to a file, and also to a csv format ( comma separated value).
Companion programs, bon csv2html and bon csv2txt , can be used convert to html and plain text output formats.
We recommend you read the man page for bonnie{pp} before using as it has quite a few options regarding which tests to perform and how exhaustive and stressful they should be.
A quick synopsis is obtained with: `pass:c[ $ bonnie++ --help bonnie++: invalid option -- ' h ' usage: bonnie++ [-d scratch-dir] [-c concurrency] [-s size(MiB)[:chunk-size(b)]] [-n number-to-stat[:max-size[:min-size][:num-directories[:chunk-size]]]] [-m machine-name] [-r ram-size-in-MiB] [-x number-of-tests] [-u uid-to-use:gid-to-use] [-g gid-to-use] [-q] [-f] [-b] [-p processes | -y] [-z seed | -Z random-file] [-D] Version: 1.96 ]` A quick test can be obtained with a command like:

`pass:c[$  time sudo bonnie++ -n 0 -u 0 -r 100 -f -b -d /mnt]` where: • `-n 0` means don't perform the file creation tests.
• `-u 0` means run as root.
• `-r 100` means pretend you have 100 MB of RAM.
• `-f` means skip per character I/O tests.
• `-b` means do a fsync after every write, which forces flushing to disk rather than just writing to cache.
• `-d /mnt` just specifies the directory to place the temporary file created;
make sure it has enough space, in this case 300MB, available.
If you don't supply a figure for your memory size, the program will figure out how much the system has and will create a testing file 2-3 times as large.
We are not doing that here because it takes much longer to get a feel for things.

``` ubuntu@ip-172-31-21-230:~$ time sudo bonnie{pp} -n 0 -u 0 -r 100 -f -b -d /mnt Using uid:0, gid:0.
Writing intelligently\...done Rewriting\...done Reading intelligently\...done start 'em\...done\...done\...done\...done\...done\...
Version  1.98       ------Sequential Output------ --Sequential Input- --Random-                     -Per Chr- --Block-- -Rewrite- -Per Chr- --Block-- --Seeks-- Name:Size etc        /sec %CP  /sec %CP  /sec %CP  /sec %CP  /sec %CP  /sec %CP ip-172-31-21-2 300M           72.8m   7 62.8m   6           {pp}{pp}+ {pp}+ {pp}{pp}+ {pp}+ Latency                       13228us   13782us                39us    2737us

1.98,1.98,ip-172-31-21-230,1,1613697968,300M,,8192,5,,,74568,7,64330,6,,,{pp}{pp}+,{pp}+,{pp}{pp}+,{pp}+,,,,,,,,,,,,,,,,,,,13228us,13782us,,39us,2737us,,,,,,

real	0m12.226s user	0m0.136s sys	0m0.675s ubuntu@ip-172-31-21-230:~$ ```

You can clearly see the drop in performance.
Assuming you have saved the previous outputs as a file called bonnie{pp}.out, you can convert the output to html: `pass:c[$ bon_csv2html < bonnie++.out > bonnie++.html]` or to plain text with: `pass:c[$ bon_csv2txt < bonnie++.out > bonnie++.txt]` After reading the documentation, try longer and larger, more ambitious tests.
Try some of the tests we turned off.
If your system is behaving well, save the results for future benchmarking comparisons when the system is sick.

image::../../_resources/2f9838f777d74d548dfbc1a349262645.png[c066d358d81b89add4501a542702d9f6.png]
